<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Jitsi Meeting Assistant Bot</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; background: #1a1a2e; color: #eee; }
    .status { margin: 0.5rem 0; padding: 0.5rem; background: #16213e; border-radius: 4px; }
    .error { color: #e94560; }
    .ok { color: #0f0; }
    #log { max-height: 200px; overflow-y: auto; font-size: 12px; }
  </style>
</head>
<body>
  <h1>Jitsi Meeting Assistant</h1>
  <div id="config" class="status"></div>
  <div id="status" class="status">Initializing…</div>
  <pre id="log"></pre>

  <script>
    (function() {
      const params = new URLSearchParams(window.location.search);
      const JITSI_DOMAIN = params.get('jitsi_domain') || 'meet.jit.si';
      const ROOM_NAME = params.get('room') || 'MeetingMonitor';
      const BOT_DISPLAY_NAME = params.get('bot_name') || 'Meeting Assistant';
      const WS_URL = params.get('ws_url') || ('ws://' + window.location.host + '/api/v1/ws/jitsi-live');
      const MEETING_ID = params.get('meeting_id') || null;

      document.getElementById('config').textContent = `Jitsi: ${JITSI_DOMAIN} | Room: ${ROOM_NAME} | Bot: ${BOT_DISPLAY_NAME}`;

      const log = (msg) => {
        const el = document.getElementById('log');
        el.textContent += new Date().toISOString().slice(11, 19) + ' ' + msg + '\n';
        el.scrollTop = el.scrollHeight;
      };

      let audioContext = null;
      const SAMPLE_RATE = 48000;
      const CHUNK_DURATION_MS = 8000;
      const SAMPLES_PER_CHUNK = (SAMPLE_RATE * CHUNK_DURATION_MS) / 1000;

      function sendChunkToBackend(participantId, displayName, pcmInt16Array) {
        const ws = new WebSocket(WS_URL.replace(/^http/, 'ws'));
        ws.binaryType = 'arraybuffer';
        ws.onopen = () => {
          const meta = {
            participantId: participantId,
            displayName: displayName,
            sampleRate: SAMPLE_RATE
          };
          if (MEETING_ID) meta.meeting_id = MEETING_ID;
          ws.send(JSON.stringify(meta));
          const buf = pcmInt16Array.buffer;
          ws.send(buf);
        };
        ws.onmessage = (e) => {
          try {
            const data = JSON.parse(e.data);
            if (data.line) log('[TRANSCRIPT] ' + data.line);
            if (data.error) log('[ERROR] ' + data.error);
          } catch (_) {}
        };
        ws.onerror = () => log('WS error for ' + displayName);
      }

      function attachTrackToCapture(track, participantId, displayName) {
        const stream = track.getOriginalStream ? track.getOriginalStream() : new MediaStream([track.track]);
        audioContext = audioContext || new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
        const source = audioContext.createMediaStreamSource(stream);
        const processor = audioContext.createScriptProcessor(4096, 1, 1);
        const buffer = [];
        processor.onaudioprocess = (e) => {
          const input = e.inputBuffer.getChannelData(0);
          for (let i = 0; i < input.length; i++) buffer.push(input[i]);
          while (buffer.length >= SAMPLES_PER_CHUNK) {
            const chunk = buffer.splice(0, SAMPLES_PER_CHUNK);
            const int16 = new Int16Array(chunk.length);
            for (let i = 0; i < chunk.length; i++)
              int16[i] = Math.max(-32768, Math.min(32767, chunk[i] * 32768));
            sendChunkToBackend(participantId, displayName, int16);
          }
        };
        source.connect(processor);
        processor.connect(audioContext.destination);
        log('Capturing audio: ' + displayName);
      }

      function onRemoteTrack(track) {
        if (track.getType && track.getType() !== 'audio') return;
        const participantId = track.getParticipantId ? track.getParticipantId() : (track.participantId || 'unknown');
        let displayName = 'Participant_' + participantId;
        if (typeof room.getParticipantById === 'function') {
          const p = room.getParticipantById(participantId);
          if (p && (p.getDisplayName || p.displayName))
            displayName = (p.getDisplayName ? p.getDisplayName() : p.displayName) || displayName;
        }
        attachTrackToCapture(track, participantId, displayName);
      }

      let connection, room;

      function init() {
        const script = document.createElement('script');
        script.src = 'https://' + JITSI_DOMAIN + '/libs/lib-jitsi-meet.min.js';
        script.onload = () => {
          const JitsiMeetJS = window.JitsiMeetJS;
          JitsiMeetJS.init();
          document.getElementById('status').textContent = 'Connecting to ' + JITSI_DOMAIN + '…';
          document.getElementById('status').className = 'status';

          const options = {
            hosts: { domain: JITSI_DOMAIN },
            serviceUrl: 'https://' + JITSI_DOMAIN + '/http-bind',
            clientNode: 'http://jitsi.org/jitsi-meet'
          };
          connection = new JitsiMeetJS.JitsiConnection(null, null, options);

          connection.addEventListener(JitsiMeetJS.events.connection.CONNECTION_ESTABLISHED, () => {
            document.getElementById('status').textContent = 'Connected. Joining room…';
            room = connection.initJitsiConference(ROOM_NAME, {
              startAudioOnly: true,
              startWithAudioMuted: true,
              enableLayerSuspension: false
            });
            room.setDisplayName(BOT_DISPLAY_NAME);
            room.on(JitsiMeetJS.events.conference.TRACK_ADDED, onRemoteTrack);
            room.on(JitsiMeetJS.events.conference.CONFERENCE_JOINED, () => {
              document.getElementById('status').textContent = 'Bot joined as "' + BOT_DISPLAY_NAME + '". Listening to participants.';
              document.getElementById('status').className = 'status ok';
              log('Conference joined.');
            });
            room.on(JitsiMeetJS.events.conference.TRACK_REMOVED, (t) => log('Track removed: ' + (t.getParticipantId && t.getParticipantId())));
            room.join();
          });

          connection.addEventListener(JitsiMeetJS.events.connection.CONNECTION_FAILED, (e) => {
            document.getElementById('status').textContent = 'Connection failed: ' + (e && e.message);
            document.getElementById('status').className = 'status error';
            log('Connection failed: ' + JSON.stringify(e));
          });
          connection.addEventListener(JitsiMeetJS.events.connection.CONNECTION_DISCONNECTED, () => {
            document.getElementById('status').textContent = 'Disconnected.';
            document.getElementById('status').className = 'status error';
          });

          connection.connect();
        };
        script.onerror = () => {
          document.getElementById('status').textContent = 'Failed to load lib-jitsi-meet from ' + JITSI_DOMAIN;
          document.getElementById('status').className = 'status error';
        };
        document.head.appendChild(script);
      }

      init();
    })();
  </script>
</body>
</html>
